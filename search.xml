<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>前端开发应该知道的浏览器知识</title>
    <url>/2025/08/08/Browser/</url>
    <content><![CDATA[<pre><code>在开发过程中我们经常会用到浏览器的，但是浏览器的一些机制是怎么运行的，代码在浏览器中是怎么执行的，如何渲染布局的，事件在触发时浏览器在做什么？下面将做细致探讨
</code></pre>
<h1 id="一、浏览器输入URL到显示页面整个过程发生了什么？"><a href="#一、浏览器输入URL到显示页面整个过程发生了什么？" class="headerlink" title="一、浏览器输入URL到显示页面整个过程发生了什么？"></a>一、浏览器输入URL到显示页面整个过程发生了什么？</h1><h1 id="二、浏览器是如何解析代码的？"><a href="#二、浏览器是如何解析代码的？" class="headerlink" title="二、浏览器是如何解析代码的？"></a>二、浏览器是如何解析代码的？</h1><h1 id="三、浏览器的垃圾回收机制"><a href="#三、浏览器的垃圾回收机制" class="headerlink" title="三、浏览器的垃圾回收机制"></a>三、浏览器的垃圾回收机制</h1><h1 id="四、浏览器的本地存储"><a href="#四、浏览器的本地存储" class="headerlink" title="四、浏览器的本地存储"></a>四、浏览器的本地存储</h1><h1 id="五、浏览器的线程"><a href="#五、浏览器的线程" class="headerlink" title="五、浏览器的线程"></a>五、浏览器的线程</h1><pre><code>JS是单线程的，而浏览器是多线程的。
</code></pre>
<h2 id="1、CPU"><a href="#1、CPU" class="headerlink" title="1、CPU"></a>1、CPU</h2><p>CPU是计算机的核心，负责承担计算机的计算任务</p>
<h2 id="2、进程"><a href="#2、进程" class="headerlink" title="2、进程"></a>2、进程</h2><p>进程是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，是操作系统进行资源分配和调度的一个独立单位，是应用程序运行的载体。</p>
<p>我们将进程比喻为工厂的车间，它代表CPU所能处理的单个任务。任一时刻，CPU总是运行一个进程，其他进程处于非运行状态。</p>
<h2 id="3、线程"><a href="#3、线程" class="headerlink" title="3、线程"></a>3、线程</h2><p>线程是程序执行中一个单一的顺序控制流程，是程序执行流的最小单位。<br>这里把线程比喻一个车间的工人，即一个车间可允许多个工人协同完成一个任务。</p>
<h2 id="4、浏览器的多线程"><a href="#4、浏览器的多线程" class="headerlink" title="4、浏览器的多线程"></a>4、浏览器的多线程</h2><p>浏览器的内核是多线程，在内核控制下各线程相互配合以保持同步，一个浏览器通常由以下常驻线程组成：</p>
<ul>
<li>GUI渲染线程</li>
<li>Javascript引擎线程</li>
<li>事件触发线程</li>
<li>定时触发器线程</li>
<li>异步http请求线程<br><img src="/" alt="常驻线程"></li>
</ul>
<h1 id="六、浏览器的兼容"><a href="#六、浏览器的兼容" class="headerlink" title="六、浏览器的兼容"></a>六、浏览器的兼容</h1><h2 id="1、-为什么代码会在浏览器中出现兼容性问题"><a href="#1、-为什么代码会在浏览器中出现兼容性问题" class="headerlink" title="1、 为什么代码会在浏览器中出现兼容性问题"></a>1、 为什么代码会在浏览器中出现兼容性问题</h2><p>因为不同的浏览器对同一段代码有不同的解析，这样会造成在不同的浏览器中显示页面的效果不统一。</p>
<h2 id="2、-我们怎么要怎么解决呢？"><a href="#2、-我们怎么要怎么解决呢？" class="headerlink" title="2、 我们怎么要怎么解决呢？"></a>2、 我们怎么要怎么解决呢？</h2><h3 id="2-1、CSS-Hack"><a href="#2-1、CSS-Hack" class="headerlink" title="2.1、CSS Hack"></a>2.1、CSS Hack</h3><p> CSS Hack是通过在CSS样式中添加一些特殊的符号也就是浏览器的前缀，让不同的浏览器识别不同的符号（什么样的浏览器识别什么样的符号都是有标准的），CSS hack就是让你记住这个标准，以达到应用不同的CSS样式的目的。</p>
<h3 id="2-2、polyfill"><a href="#2-2、polyfill" class="headerlink" title="2.2、polyfill"></a>2.2、polyfill</h3><p> 在JS方面，可以使用polyfill，polyfill是一段代码（或者插件），提供了那些开发者们希望浏览器原生提供支持的功能。程序先检查浏览器是否支持某个API，如果不支持则加载对象的polyfill。比如，html5的storge。不同浏览器，不同版本，有些支持，有些不支持。其实polyfill就是shim的一种。</p>
<h4 id="2-2-1、-polyfill的核心概念："><a href="#2-2-1、-polyfill的核心概念：" class="headerlink" title="2.2.1、 polyfill的核心概念："></a>2.2.1、 polyfill的核心概念：</h4><p>当浏览器缺乏对某些新特性的原生支持时（例如IE浏览器不支持Promise或fetch），polyfill会通过JS动态注入代码来模拟这些功能的行为，使得开发者无需针对不同浏览器编写分支逻辑</p>
<h3 id="2-2-2-、工作原理："><a href="#2-2-2-、工作原理：" class="headerlink" title="2.2.2 、工作原理："></a>2.2.2 、工作原理：</h3><ul>
<li>检测机制：首先检查浏览器是否原生支持某些特性（例如通过if(!window.Promise)）</li>
<li>动态模拟：若不支持，则加载polyfill代码事项等效功能（例如用setTimeout模拟Promise）</li>
<li>透明替换： 模拟后的API调用方式与原生一致，开发者无需修改业务代码</li>
</ul>
<h4 id="2-2-3、应用场景"><a href="#2-2-3、应用场景" class="headerlink" title="2.2.3、应用场景"></a>2.2.3、应用场景</h4><ul>
<li>在IE中实现ES6的Promise、Array.from()等语法。</li>
<li>为不支持CSS3媒体查询（如IE8）的浏览器提供响应式布局能力（如使用respond.js）。</li>
<li>模拟HTML5的拖放API（Drag and Drop）或Canvas绘图功能。</li>
</ul>
<h4 id="2-2-4、与Shim的区别"><a href="#2-2-4、与Shim的区别" class="headerlink" title="2.2.4、与Shim的区别"></a>2.2.4、与Shim的区别</h4><p>polyfill：严格模拟标准的API的行为，目标是实现与规范一致的接口<br>Shim：更广义的兼容层，可能包含非标准实现或简化功能。（例如早期Query统一事件处理）</p>
<h3 id="2-3、PostCSS"><a href="#2-3、PostCSS" class="headerlink" title="2.3、PostCSS"></a>2.3、PostCSS</h3><p>PostCSS是一个利用JS插件来对CSS进行转换的工具，这些插件非常强大，强大到无所不能。其中，Autoprefixer就是众多PostCSS插件中最流行的一个。</p>
<p>Autoprefixer可以自动帮我们加上浏览器前缀。</p>
<h3 id="2-4、Modernizr-js"><a href="#2-4、Modernizr-js" class="headerlink" title="2.4、Modernizr.js"></a>2.4、Modernizr.js</h3><p>Modernizr.js十分的强大，既能给老版本浏览器打补丁，又能保证新浏览器渐进增强的用户体验。<br>Modernizr默认做的事情很少，除了（在你选择的情况下）给不支持html5的标签的浏览器，如IE6，7，8追加一点由Remy Sharp开发的html5垫片脚本，使其识别、等html5元素之外，它主要做的就是浏览器功能检测。因此，它知道浏览器是否支持各种html5和css3特性。</p>
<h1 id="七、浏览器的安全"><a href="#七、浏览器的安全" class="headerlink" title="七、浏览器的安全"></a>七、浏览器的安全</h1>]]></content>
  </entry>
  <entry>
    <title>Node.js之语法</title>
    <url>/2025/08/05/NodeJS/</url>
    <content><![CDATA[<p>Node.js简单来说就是运行在服务端的JS<br>Node.js是一个基于Chrome JS运行时建立的一个平台<br>Node.js是一个事件驱动I&#x2F;O服务端JS环境，基于谷歌的V8引擎，V8引擎执行JS的速度非常快，速度非常好。</p>
<span id="more"></span>
<h1 id="一、Node-js的概念"><a href="#一、Node-js的概念" class="headerlink" title="一、Node.js的概念"></a>一、Node.js的概念</h1><pre><code>Node.js是一个基于Chrome V8 JavaScript引擎构建的JS运行时环境，简单来说，Node.js让JS可以在服务端运行，而不仅仅局限于浏览器中。
</code></pre>
<h1 id="二、Node-js的特点"><a href="#二、Node-js的特点" class="headerlink" title="二、Node.js的特点"></a>二、Node.js的特点</h1><h2 id="单线程事件循环"><a href="#单线程事件循环" class="headerlink" title="单线程事件循环"></a>单线程事件循环</h2><h2 id="非阻塞I-O"><a href="#非阻塞I-O" class="headerlink" title="非阻塞I&#x2F;O"></a>非阻塞I&#x2F;O</h2><pre><code>    所有的I/O操作都是异步的
</code></pre>
<h2 id="跨平台"><a href="#跨平台" class="headerlink" title="跨平台"></a>跨平台</h2><pre><code>    一次编写到处运行（Win\macOS\Linux）
</code></pre>
<h2 id="丰富的生态系统"><a href="#丰富的生态系统" class="headerlink" title="丰富的生态系统"></a>丰富的生态系统</h2><h1 id="三、Node-js的应用场景"><a href="#三、Node-js的应用场景" class="headerlink" title="三、Node.js的应用场景"></a>三、Node.js的应用场景</h1><ul>
<li>web应用程序</li>
<li>实时应用</li>
<li>微服务架构</li>
<li>工具和命令行应用</li>
<li>物联网应用</li>
</ul>
<h1 id="四、Node-js的工作机制"><a href="#四、Node-js的工作机制" class="headerlink" title="四、Node.js的工作机制"></a>四、Node.js的工作机制</h1><h1 id="五、Node-js的基础使用"><a href="#五、Node-js的基础使用" class="headerlink" title="五、Node.js的基础使用"></a>五、Node.js的基础使用</h1><h2 id="1、Node-js-REPL-交互式解释器"><a href="#1、Node-js-REPL-交互式解释器" class="headerlink" title="1、Node.js REPL(交互式解释器)"></a>1、Node.js REPL(交互式解释器)</h2><p>R:读取<br>E:执行<br>P:打印<br>L:循环<br>启用Node终端</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node</span><br></pre></td></tr></table></figure>
<h2 id="2、Node-js的异步编程"><a href="#2、Node-js的异步编程" class="headerlink" title="2、Node.js的异步编程"></a>2、Node.js的异步编程</h2><h3 id="2-1、Node-js异步变成的三种方式"><a href="#2-1、Node-js异步变成的三种方式" class="headerlink" title="2.1、Node.js异步变成的三种方式"></a>2.1、Node.js异步变成的三种方式</h3><h4 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var fs = require(&quot;fs&quot;);</span><br><span class="line"></span><br><span class="line">fs.readFile(&#x27;input.txt&#x27;, function (err, data) &#123;</span><br><span class="line">    if (err) return console.error(err);</span><br><span class="line">    console.log(data.toString());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(&quot;程序执行结束!&quot;);</span><br></pre></td></tr></table></figure>
<h4 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">myPromise</span><br><span class="line">  .then((result) =&gt; &#123;</span><br><span class="line">    console.log(result); // 输出：&quot;操作成功！&quot;</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch((error) =&gt; &#123;</span><br><span class="line">    console.error(error); // 输出：&quot;操作失败！&quot;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<h4 id="sync-await"><a href="#sync-await" class="headerlink" title="sync&#x2F;await"></a>sync&#x2F;await</h4><ul>
<li>await只能在async函数内部使用给，他会暂停函数的执行，等待Promise解决，然后继续执行并返回结果<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">async function myFunction() &#123;</span><br><span class="line">  return &quot;Hello World&quot;;</span><br><span class="line">&#125;</span><br><span class="line">async function fetchData() &#123;</span><br><span class="line">  const response = await fetch(&#x27;https://api.example.com/data&#x27;);</span><br><span class="line">  const data = await response.json();</span><br><span class="line">  return data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>错误处理<br>try…catch<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">async function getUser() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    const response = await fetch(&#x27;https://api.example.com/user&#x27;);</span><br><span class="line">    const user = await response.json();</span><br><span class="line">    return user;</span><br><span class="line">  &#125; catch (error) &#123;</span><br><span class="line">    console.error(&#x27;Error fetching user:&#x27;, error);</span><br><span class="line">    throw error; // 可以选择重新抛出错误</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//直接处理</span><br><span class="line">getUser()</span><br><span class="line">  .then(user =&gt; console.log(user))</span><br><span class="line">  .catch(error =&gt; console.error(error));</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3、事件循环"><a href="#3、事件循环" class="headerlink" title="3、事件循环"></a>3、事件循环</h2><p>事件循环是 Node.js 处理非阻塞 I&#x2F;O 操作的核心机制</p>
<h3 id="3-1、事件循环的阶段"><a href="#3-1、事件循环的阶段" class="headerlink" title="3.1、事件循环的阶段"></a>3.1、事件循环的阶段</h3><p>事件循环分为多个阶段，每个阶段处理特定的任务。关键阶段如下：</p>
<ul>
<li>Timers：执行 setTimeout() 和 setInterval() 的回调。</li>
<li>I&#x2F;O Callbacks：处理一些延迟的 I&#x2F;O 回调。</li>
<li>Idle, prepare：内部使用，不常见。</li>
<li>Poll：检索新的 I&#x2F;O 事件，执行与 I&#x2F;O 相关的回调。</li>
<li>Check：执行 setImmediate() 回调。</li>
<li>Close Callbacks：处理关闭的回调，如 socket.on(‘close’, …)。</li>
</ul>
<h3 id="3-2、事件循环的流程"><a href="#3-2、事件循环的流程" class="headerlink" title="3.2、事件循环的流程"></a>3.2、事件循环的流程</h3><ul>
<li>任务进入事件循环队列。</li>
<li>事件循环按照阶段顺序进行处理，每个阶段有自己的回调队列。</li>
<li>事件循环会在 poll 阶段等待新的事件到达，如果没有事件，会检查其他阶段的回调。</li>
<li>如果 setImmediate() 和 setTimeout() 都存在，setImmediate() 在 check 阶段先执行，而 setTimeout() 在 timers 阶段执行。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2025/08/04/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><span id="more"></span>
<h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
</search>
